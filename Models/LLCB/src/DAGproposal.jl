# This code defines and customizes a proposal mechanism within a Markov Chain Monte Carlo (MCMC)
# framework, specifically for sampling directed acyclic graphs(DAGs).
# The code appears to be implementing a custom proposal type, DAGproposal, for use with an MCMC library called AdvancedMH

# 1. DAGProposal Struct:
# DAGProposal is a mutable struct tht extends AdvancedMH.Proposal, parameterized by type P.
mutable struct DAGProposal{P} <: AdvancedMH.Proposal{P}
    proposal::P # Stores the current proposal of the DAG
    accepted::Int64 # Track the count of accepted and total proposals, used for tracking acceptance rate.
    total   ::Int64
    X       ::Matrix{Float64}   # Represent data matrices associated with the proposal
    interventions::Matrix{Int8}
end

# 2. Constructor: Initialize a DAGProposal instance with accpted and total set to zero.
function DAGProposal(p::DAG, X, interventions) 
    DAGProposal(p, 0, 0, X, interventions)
end

# 3. Accepted Counting Functions: accepted! functions update the count of accepted proposals by one, for boh single and vector/named tuple forms of DAGProposal
accepted!(p::DAGProposal) = p.accepted += 1
accepted!(p::Vector{<:DAGProposal}) = map(accepted!, p)
accepted!(p::NamedTuple{names}) where names = map(x->accepted!(getfield(p, x)), names)

# 4. Custom Proposal Mechanism: Provides a fallback proposal when no transition exists (likely for the first sample)
# this is defined because the first draw has no transition yet (I think)
AdvancedMH.propose(rng::Random.AbstractRNG, p::DAGProposal, m::DensityModel) = 
    rand(rng, p.proposal)

# 5. Main Proposal Mechanism:
# the actual proposal happens here
function AdvancedMH.propose(
    rng::Random.AbstractRNG,
    proposal::DAGProposal,
    model::DensityModel,
    t   # A permutation of nodes (gene indices) is generated by a topological sort on the adjacency matrix t
)
    proposal.total += 1
    nv = size(t, 1) # genes 

    println("current transition is $t")
    x = deepcopy(t)
    perm = topological_sort(BitMatrix(x .!= 0))
    new_perm = deepcopy(perm)

    # A node swap operation is randomly applied, swapping positions in the topological order, thus altering the proposed DAG structure
    node_swap = rand(1:nv)
    local node_swap_partner

    if node_swap == 1
        node_swap_partner = 2
        @assert nv >= node_swap_partner && node_swap_partner >= 1
    elseif node_swap == nv
        node_swap_partner = nv - 1
        @assert nv >= node_swap_partner && node_swap_partner >= 1
    else
        node_swap_partner = node_swap + rand((-1, 1))
    end

    new_perm[node_swap] = perm[node_swap_partner]
    new_perm[node_swap_partner] = perm[node_swap]

    println("perm = $perm")
    println("new_perm = $new_perm")
    @assert new_perm != perm

    # The modified DAGstructure, proposed_g, is constructed using an IMAP function, which appears to handle the DAG recording
    proposed_g = IMAP(new_perm, .01, proposal.X, proposal.interventions)
    println("proposed transition is $proposed_g")

    return proposed_g
end

# 6. Proposal Density (q): Returns a constant proposal density, implying symmetric proposal probabilities, simplifying calcuations by assuming equal probability of proposing each transition.
function AdvancedMH.q(proposal::DAGProposal, t, t_cond) 
    # logpdf(proposal, t - t_cond)
    # logpdf(proposal, t - t_cond)
    return 0.0
end

# 7. MCMC Step Function:
# Define the other sampling steps.
# Return a 2-tuple consisting of the next sample and the the next state.
# In this case they are identical, and either a new proposal (if accepted)
# or the previous proposal (if not accepted).
function AbstractMCMC.step(
    rng::Random.AbstractRNG,
    model::DensityModel,
    sampler::AdvancedMH.MHSampler,
    transition_prev::AdvancedMH.AbstractTransition;
    kwargs...
)
    # Generate a new proposal.
    println("step here 1")
    candidate = AdvancedMH.propose(rng, sampler, model, transition_prev)
    println("step here 2")

    # candidate: A proposed new stage, generated by calling AdvancedMH.propose.
    # Calculate the log acceptance probability and the log density of the candidate.
    logdensity_candidate = AdvancedMH.logdensity(model, candidate)
    loga = logdensity_candidate - AdvancedMH.logdensity(model, transition_prev) +
        AdvancedMH.logratio_proposal_density(sampler, transition_prev, candidate)

    # Acceptance Check: The log-acceptance ratio (loga) compares the likelihood of the candidate and previous transition states.
    # Decide whether to return the previous params or the new one.
    transition = if -Random.randexp(rng) < loga
	accepted!(sampler.proposal)
        # println("accepted!")
        AdvancedMH.transition(sampler, model, candidate, logdensity_candidate)
    else
        # println("rejected!")
        AdvancedMH.transition(sampler, model, candidate, logdensity_candidate)
        transition_prev
    end

    return transition, transition
end

accepted!(p::AdvancedMH.RandomWalkProposal) = nothing
accepted!(p::AdvancedMH.StaticProposal) = nothing

# 8. Parameter Initialization:
function DynamicPPL.initialize_parameters!!(vi::AbstractVarInfo, init_params, spl::Sampler)
    @debug "Using passed-in initial variable values" init_params

    # Initializes parameters for MCMC sampling, flattening init_params into a single vector and validating its legnth
    println("init_params = $init_params")
    # Flatten parameters.
    init_theta = mapreduce(vcat, init_params) do x
        vec([x;])
    end

    # Updates theta, the variable information, ensuring it matches the model's dimensions
    println("init_theta = $init_theta")
    # Get all values.
    linked = DynamicPPL.islinked(vi, spl)
    if linked
        # TODO: Make work with immutable `vi`.
        DynamicPPL.invlink!(vi, spl)
    end
    theta = vi[spl]

    println("length(theta) = $(length(theta))")
    println("length(init_theta) = $(length(init_theta))")

    length(theta) == length(init_theta) ||
        error("Provided initial value doesn't match the dimension of the model")


    # Update values that are provided.
    for i in 1:length(init_theta)
        x = init_theta[i]
        if x !== missing
            theta[i] = x
        end
    end

    # Update in `vi`.
    vi = DynamicPPL.setindex!!(vi, theta, spl)
    if linked
        # TODO: Make work with immutable `vi`.
        DynamicPPL.link!(vi, spl)
    end

    return vi
end
